## 983 数组形式的整数加法:star:

<img src="贪婪算法.assets/image-20210122142326624.png" alt="image-20210122142326624" style="zoom: 67%;" />

```c++
class Solution {
public:
    vector<int> addToArrayForm(vector<int>& A, int K) {
        int add = 0;
        int pos = 0;
        int len = A.size();
        reverse(A.begin(), A.end());

        while (K > 0 && pos < len)
        {
            int a = K % 10;
            int temp = A[pos] + a + add;
            A[pos] = temp % 10;
            add = temp / 10;
            K = K / 10;
            pos++;
        }

        while (K > 0)
        {
            A.push_back((add + K % 10) % 10);
            add = (add + K % 10) / 10;
            K = K / 10;
        }

        while (pos < len)
        {
            int temp = A[pos] + add;
            A[pos] = temp % 10;
            add = temp / 10;
            pos++;
        }

        if(add > 0)A.push_back(add);

        reverse(A.begin(), A.end());
        
        return A;
    }
};
```

![image-20210122142432418](贪婪算法.assets/image-20210122142432418.png)



## 55 跳跃游戏:star::star:

<img src="贪婪算法.assets/image-20210122143637840.png" alt="image-20210122143637840" style="zoom:67%;" />

```c
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 1)return true;
        int max_step = 0;
        for (int i = 0;i < nums.size();i++)
        {
            if (nums[i] == 0 && max_step <= i && i != nums.size() - 1)return false;
            if (i + nums[i] > max_step)max_step = i + nums[i];
        }
        return true;
    }
};
```

![image-20210122143656612](贪婪算法.assets/image-20210122143656612.png)

解题思路：要明确题目隐含的规则——只要能够通过0，就必然可以到达终点



## 134 加油站:star::star:

![image-20210122160026379](贪婪算法.assets/image-20210122160026379.png)

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int len = cost.size();
        int pos = -1;
        int temp = 0;
        vector<int> piece_sum;

        for (int i = 0;i < len;i++)
        {
            gas[i] = gas[i] - cost[i];

            if (gas[i] >= 0 && temp == 0)
            {
                pos = i;
            }

            temp += gas[i];
            if (temp < 0)
            {
                piece_sum.push_back(temp);
                temp = 0;
            }
        }
        
        for (int i = 0;i < piece_sum.size();i++)
        {
            temp += piece_sum[i];
            if (i != piece_sum.size() && temp < 0)return -1;
        }

        return pos;
    }
};
```

![image-20210122160105532](贪婪算法.assets/image-20210122160105532.png)

解题思路：总体思路是，在进行数组遍历的时候，单独的负节点作为一个`Piece`存储起来；以正节点为起点，到达某一个节点时，整个分段之和小于0的，已经失去了作为起点的资格，其和也作为`Piece`存储起来。以唯一的一个正分路（当然，可能没有），和之前的Piece依次相加，如果小于0，则视为没有答案（最后一个"Piece"不用相加，根据此题的性质）



## 316 去除重复字母:star::star:❓️

![image-20210122182716836](贪婪算法.assets/image-20210122182716836.png)

```c++
class Solution {
public:
    string removeDuplicateLetters(string s) {

       vector<int> vis(26), num(26);
        for (char ch : s) {
            num[ch - 'a']++;
        }

        string stk;
        for (char ch : s) {
            if (!vis[ch - 'a']) {
                while (!stk.empty() && stk.back() > ch) {
                    if (num[stk.back() - 'a'] > 0) {
                        vis[stk.back() - 'a'] = 0;
                        stk.pop_back();
                    } else {
                        break;
                    }
                }
                vis[ch - 'a'] = 1;
                stk.push_back(ch);
            }
            num[ch - 'a'] -= 1;
        }
        return stk;
    }
};
```

![image-20210122182939342](贪婪算法.assets/image-20210122182939342.png)